<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/model/TruckRoute.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/model/TruckRoute.java" />
              <option name="originalContent" value="&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class TruckRoute {&#10;    private String truckId;&#10;    private int distance;&#10;    private int transportTime;&#10;    private List&lt;Activity&gt; activities;&#10;    private List&lt;String&gt; assignedParcels;&#10;    private String warehouseVisited;&#10;    private double capacityUsed;&#10;    private double totalCapacity;&#10;    private double capacityUtilizationPercent;&#10;}" />
              <option name="updatedContent" value="import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.util.List;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class TruckRoute {&#10;    private String truckId;&#10;    private int distance;&#10;    private int transportTime;&#10;    private List&lt;Activity&gt; activities;&#10;    private List&lt;String&gt; assignedParcels;&#10;    private String warehouseVisited;&#10;    private double capacityUsed;&#10;    private double totalCapacity;&#10;    private double capacityUtilizationPercent;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/computation/helper/tomtom/RoutingProblemSolver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/computation/helper/tomtom/RoutingProblemSolver.java" />
              <option name="originalContent" value="package com.saxion.proj.tfms.routing.service.computation.helper.tomtom;&#10;&#10;import com.saxion.proj.tfms.commons.constants.StopType;&#10;import com.saxion.proj.tfms.routing.model.*;&#10;import com.saxion.proj.tfms.routing.service.computation.helper.RoutingProvider;&#10;import com.saxion.proj.tfms.routing.service.computation.helper.constants.Patterns;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@Service(&quot;RoutingProblemSolver&quot;)&#10;public class RoutingProblemSolver implements RoutingProvider {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(RoutingProblemSolver.class);&#10;&#10;    @Autowired&#10;    private TomTomRouteCalculator tomTomRouteCalculator;&#10;&#10;&#10;    @Override&#10;    public List&lt;Stop&gt; calculateRoute(RouteCoordinatesGroup routeCoordinatesGroup) {&#10;&#10;        Coordinates depotCoordinate = routeCoordinatesGroup.getDepot();&#10;        Coordinates warehouseCoordinates = routeCoordinatesGroup.getWarehouse();&#10;        List&lt;Coordinates&gt; parcels = routeCoordinatesGroup.getParcels();&#10;        List&lt;Parcel&gt; parcelList = routeCoordinatesGroup.getParcelList();&#10;&#10;&#10;        // Step 1: Initial heuristic clustering by shift time&#10;        Map&lt;Coordinates, Double&gt; coordinatesDistanceMap = HeuristicsDistanceFinder.findStraightDistanceInkm(warehouseCoordinates, parcels);&#10;&#10;        ClusterResult heuristicClusters = HeuristicsClusterMaker.clusterByShift(&#10;                coordinatesDistanceMap,&#10;                warehouseCoordinates,&#10;                Patterns.PATTERN_HEURISTIC,&#10;                8,&#10;                40&#10;        );&#10;&#10;        // Step 2: Optimize each cluster using TomTom and rebalance if needed&#10;        ClusterResult optimizedClusters = optimizeClustersWithTomTom(&#10;                warehouseCoordinates,&#10;                heuristicClusters,&#10;                Patterns.PATTERN_REALISTIC&#10;        );&#10;&#10;        double a = optimizedClusters.getClusterDistanceinKm();&#10;        int b = optimizedClusters.getClusteringTimeInMinutes();&#10;&#10;        // Step 3: Convert optimized clusters to stops&#10;        List&lt;Stop&gt; stops = convertClustersToStops(&#10;                depotCoordinate,&#10;                warehouseCoordinates,&#10;                optimizedClusters,&#10;                parcelList&#10;        );&#10;&#10;        return stops;&#10;    }&#10;&#10;&#10;&#10;    /**&#10;     * Optimize each cluster using TomTom API and rebalance deliveries if time exceeds 2.5 hours&#10;     * Also stores route metrics (distance, time) for each truck/shift&#10;     * IMPORTANT: Deduplicates identical coordinates before sending to TomTom to avoid duplicate waypoints&#10;     */&#10;    private ClusterResult optimizeClustersWithTomTom(&#10;            Coordinates warehouse,&#10;            ClusterResult heuristicClusters,&#10;            List&lt;Patterns.ShiftBlock&gt; shiftBlocks&#10;    ) {&#10;        Map&lt;Integer, List&lt;Coordinates&gt;&gt; clusters = heuristicClusters.getShiftClusters();&#10;        List&lt;Coordinates&gt; undelivered = new ArrayList&lt;&gt;(heuristicClusters.getUndeliveredParcels());&#10;        Map&lt;Integer, TruckRouteMetrics&gt; truckMetricsMap = new java.util.HashMap&lt;&gt;();&#10;&#10;        log.debug(&quot;Starting optimization with {} clusters&quot;, clusters.size());&#10;&#10;        // Process each cluster and validate with TomTom&#10;        for (int shiftIndex = 0; shiftIndex &lt; shiftBlocks.size(); shiftIndex++) {&#10;            log.debug(&quot;Processing Shift {}&quot;, shiftIndex);&#10;&#10;            List&lt;Coordinates&gt; clusterDeliveries = clusters.get(shiftIndex);&#10;&#10;            if (clusterDeliveries == null || clusterDeliveries.isEmpty()) {&#10;                log.debug(&quot;Skipping empty cluster for shift {}&quot;, shiftIndex);&#10;                continue;&#10;            }&#10;&#10;            log.debug(&quot;Original cluster deliveries: {}&quot;, clusterDeliveries.size());&#10;&#10;            Patterns.ShiftBlock shift = shiftBlocks.get(shiftIndex);&#10;            int maxTimeSeconds = calculateMaxTimeSeconds(shift);&#10;&#10;            // Deduplicate identical coordinates (multiple parcels at same location = 1 stop for TomTom)&#10;            List&lt;Coordinates&gt; uniqueCoordinates = deduplicateCoordinates(clusterDeliveries);&#10;            log.debug(&quot;After deduplication: {} unique coordinates&quot;, uniqueCoordinates.size());&#10;&#10;            // Get TomTom optimized route and time using UNIQUE coordinates only&#10;            com.fasterxml.jackson.databind.JsonNode routeResponse =&#10;                    tomTomRouteCalculator.getOptimizedRoute(warehouse, uniqueCoordinates);&#10;&#10;            if (routeResponse != null &amp;&amp; routeResponse.has(&quot;routes&quot;) &amp;&amp; routeResponse.get(&quot;routes&quot;).size() &gt; 0) {&#10;                log.debug(&quot;TomTom response received for shift {}&quot;, shiftIndex);&#10;&#10;                com.fasterxml.jackson.databind.JsonNode summary =&#10;                    routeResponse.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;);&#10;&#10;                int actualTimeSeconds = summary.get(&quot;travelTimeInSeconds&quot;).asInt();&#10;                int actualDistanceMeters = summary.get(&quot;lengthInMeters&quot;).asInt();&#10;&#10;                // Extract the REARRANGED coordinates from TomTom response&#10;                List&lt;Coordinates&gt; optimizedSequence = tomTomRouteCalculator.getOptimizedSequence(routeResponse, uniqueCoordinates);&#10;&#10;                log.debug(&quot;Optimized sequence size: {}&quot;, optimizedSequence != null ? optimizedSequence.size() : 0);&#10;&#10;                // Ensure we never store empty list - optimizedSequence should have coordinates&#10;                if (optimizedSequence == null || optimizedSequence.isEmpty()) {&#10;                    log.warn(&quot;Optimized sequence empty for shift {}, using {} unique coordinates as fallback&quot;,&#10;                        shiftIndex, uniqueCoordinates.size());&#10;                    clusters.put(shiftIndex, uniqueCoordinates);&#10;                } else {&#10;                    log.debug(&quot;Shift {}: Storing {} optimized coordinates&quot;, shiftIndex, optimizedSequence.size());&#10;                    clusters.put(shiftIndex, optimizedSequence);&#10;                }&#10;&#10;                // Store metrics for this truck/shift&#10;                TruckRouteMetrics metrics = new TruckRouteMetrics(&#10;                    shiftIndex,&#10;                    actualDistanceMeters,&#10;                    actualTimeSeconds,&#10;                    optimizedSequence == null || optimizedSequence.isEmpty() ? uniqueCoordinates.size() : optimizedSequence.size()&#10;                );&#10;&#10;                // If time exceeds limit, move excess deliveries to next cluster or undelivered&#10;                if (actualTimeSeconds &gt; maxTimeSeconds) {&#10;                    log.info(&quot;Time exceeded for shift {} ({}s &gt; {}s), rebalancing&quot;,&#10;                        shiftIndex, actualTimeSeconds, maxTimeSeconds);&#10;&#10;                    List&lt;Coordinates&gt; toRebalance = (optimizedSequence == null || optimizedSequence.isEmpty()) ? uniqueCoordinates : optimizedSequence;&#10;&#10;                    List&lt;Coordinates&gt; rebalanced = rebalanceCluster(&#10;                            warehouse,&#10;                            toRebalance,&#10;                            maxTimeSeconds,&#10;                            shiftIndex,&#10;                            clusters,&#10;                            undelivered&#10;                    );&#10;&#10;                    log.debug(&quot;After rebalancing: {} coordinates&quot;, rebalanced.size());&#10;&#10;                    // Deduplicate rebalanced list before storing&#10;                    List&lt;Coordinates&gt; deduplicatedRebalanced = deduplicateCoordinates(rebalanced);&#10;                    log.debug(&quot;After deduplication: {} coordinates&quot;, deduplicatedRebalanced.size());&#10;&#10;                    clusters.put(shiftIndex, deduplicatedRebalanced);&#10;&#10;                    // Update metrics after rebalancing&#10;                    com.fasterxml.jackson.databind.JsonNode rebalancedResponse =&#10;                            tomTomRouteCalculator.getOptimizedRoute(warehouse, deduplicatedRebalanced);&#10;                    if (rebalancedResponse != null &amp;&amp; rebalancedResponse.has(&quot;routes&quot;) &amp;&amp; rebalancedResponse.get(&quot;routes&quot;).size() &gt; 0) {&#10;                        TruckRouteMetrics updatedMetrics = getTruckRouteMetrics(rebalancedResponse, shiftIndex, deduplicatedRebalanced);&#10;&#10;                        log.debug(&quot;Updated metrics after rebalancing for shift {}&quot;, shiftIndex);&#10;                    }&#10;                }&#10;            } else {&#10;                // FALLBACK: TomTom API failed or returned empty response&#10;                // Keep the original deduplicated coordinates instead of losing them&#10;                log.warn(&quot;TomTom API failed for shift {}, using {} fallback coordinates&quot;,&#10;                    shiftIndex, uniqueCoordinates.size());&#10;                clusters.put(shiftIndex, uniqueCoordinates);&#10;&#10;                // Try to estimate metrics manually&#10;                int estimatedTime = (uniqueCoordinates.size() - 1) * 600; // ~10 min per stop estimate&#10;                TruckRouteMetrics metrics = new TruckRouteMetrics(&#10;                    shiftIndex,&#10;                    0,  // Distance unknown&#10;                    estimatedTime,&#10;                    uniqueCoordinates.size()&#10;                );&#10;&#10;            }&#10;&#10;            // Verify what's actually in the cluster now&#10;            List&lt;Coordinates&gt; verifyCluster = clusters.get(shiftIndex);&#10;            log.debug(&quot;Cluster {} now has {} coordinates&quot;, shiftIndex,&#10;                verifyCluster != null ? verifyCluster.size() : 0);&#10;        }&#10;&#10;        log.debug(&quot;Final cluster status: {} clusters processed&quot;, shiftBlocks.size());&#10;&#10;        // Update time and distance in ClusterResult&#10;        ClusterResult result = new ClusterResult(clusters, undelivered);&#10;&#10;        // Calculate total distance and time from all truck metrics&#10;        int totalDistanceMeters = 0;&#10;        int totalTimeSeconds = 0;&#10;&#10;&#10;        // Convert to appropriate units and set in ClusterResult&#10;        result.setClusterDistanceinKm(totalDistanceMeters / 1000.0);&#10;        result.setClusteringTimeInMinutes(totalTimeSeconds / 60);&#10;&#10;        log.info(&quot;Total route metrics - Distance: {} km, Time: {} minutes&quot;,&#10;            result.getClusterDistanceinKm(), result.getClusteringTimeInMinutes());&#10;&#10;        return result;&#10;    }&#10;&#10;    private TruckRouteMetrics getTruckRouteMetrics(com.fasterxml.jackson.databind.JsonNode rebalancedResponse, int shiftIndex, List&lt;Coordinates&gt; rebalanced) {&#10;        com.fasterxml.jackson.databind.JsonNode rebalancedSummary =&#10;            rebalancedResponse.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;);&#10;&#10;        TruckRouteMetrics updatedMetrics = new TruckRouteMetrics(&#10;                shiftIndex,&#10;            rebalancedSummary.get(&quot;lengthInMeters&quot;).asInt(),&#10;            rebalancedSummary.get(&quot;travelTimeInSeconds&quot;).asInt(),&#10;            rebalanced.size()&#10;        );&#10;        return updatedMetrics;&#10;    }&#10;&#10;    /**&#10;     * Calculate maximum time in seconds for a shift (work time - breaks + buffer)&#10;     */&#10;    private int calculateMaxTimeSeconds(Patterns.ShiftBlock shift) {&#10;        int trafficBuffer = (shift.workMinutes / 60) * shift.trafficBufferPerHour;&#10;        int availableMinutes = shift.workMinutes - shift.breakMinutes + trafficBuffer;&#10;        return availableMinutes * 60; // Convert to seconds&#10;    }&#10;&#10;    /**&#10;     * Remove duplicate coordinates (multiple parcels at same location)&#10;     * Keeps first occurrence, removes subsequent identical coordinates&#10;     * @param coordinates List that may contain duplicates&#10;     * @return List with only unique coordinates (by lat/lon)&#10;     */&#10;    private List&lt;Coordinates&gt; deduplicateCoordinates(List&lt;Coordinates&gt; coordinates) {&#10;        List&lt;Coordinates&gt; unique = new ArrayList&lt;&gt;();&#10;&#10;        for (Coordinates coord : coordinates) {&#10;            boolean isDuplicate = false;&#10;&#10;            // Check if this coordinate already exists in unique list&#10;            for (Coordinates existing : unique) {&#10;                if (Math.abs(existing.getLatitude() - coord.getLatitude()) &lt; 0.000001 &amp;&amp;&#10;                    Math.abs(existing.getLongitude() - coord.getLongitude()) &lt; 0.000001) {&#10;                    isDuplicate = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            // Add only if not a duplicate&#10;            if (!isDuplicate) {&#10;                unique.add(coord);&#10;            }&#10;        }&#10;&#10;        return unique;&#10;    }&#10;&#10;    /**&#10;     * Rebalance cluster by removing deliveries until time constraint is met&#10;     * If even a single delivery exceeds time, move all to next shift/undelivered&#10;     */&#10;    private List&lt;Coordinates&gt; rebalanceCluster(&#10;            Coordinates warehouse,&#10;            List&lt;Coordinates&gt; clusterDeliveries,&#10;            int maxTimeSeconds,&#10;            int currentShiftIndex,&#10;            Map&lt;Integer, List&lt;Coordinates&gt;&gt; allClusters,&#10;            List&lt;Coordinates&gt; undelivered&#10;    ) {&#10;        List&lt;Coordinates&gt; balanced = new ArrayList&lt;&gt;(clusterDeliveries);&#10;&#10;        log.debug(&quot;Rebalancing: Starting with {} deliveries, max time: {}s&quot;, balanced.size(), maxTimeSeconds);&#10;&#10;        // Remove deliveries from the end until time fits&#10;        while (!balanced.isEmpty()) {&#10;            com.fasterxml.jackson.databind.JsonNode response =&#10;                    tomTomRouteCalculator.getOptimizedRoute(warehouse, balanced);&#10;&#10;            if (response != null &amp;&amp; response.has(&quot;routes&quot;) &amp;&amp; response.get(&quot;routes&quot;).size() &gt; 0) {&#10;                int time = response.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;).get(&quot;travelTimeInSeconds&quot;).asInt();&#10;&#10;                log.debug(&quot;Testing with {} deliveries: {}s&quot;, balanced.size(), time);&#10;&#10;                if (time &lt;= maxTimeSeconds) {&#10;                    // Time fits! Now move excess deliveries to next cluster or undelivered&#10;                    // Important: collect removed items before modifying balanced list&#10;                    List&lt;Coordinates&gt; removed = new ArrayList&lt;&gt;();&#10;                    for (int i = balanced.size(); i &lt; clusterDeliveries.size(); i++) {&#10;                        removed.add(clusterDeliveries.get(i));&#10;                    }&#10;&#10;                    if (!removed.isEmpty()) {&#10;                        log.info(&quot;Moving {} deliveries to next shift/undelivered&quot;, removed.size());&#10;&#10;                        // Try to add to next cluster&#10;                        int nextShift = currentShiftIndex + 1;&#10;                        if (allClusters.containsKey(nextShift)) {&#10;                            List&lt;Coordinates&gt; nextCluster = allClusters.get(nextShift);&#10;                            nextCluster.addAll(0, removed); // Add at beginning&#10;                            log.debug(&quot;Added {} deliveries to shift {}&quot;, removed.size(), nextShift);&#10;                        } else {&#10;                            undelivered.addAll(removed);&#10;                            log.debug(&quot;Added {} deliveries to undelivered list&quot;, removed.size());&#10;                        }&#10;                    }&#10;&#10;                    log.debug(&quot;Rebalancing complete: keeping {} deliveries&quot;, balanced.size());&#10;                    return balanced;&#10;                }&#10;            }&#10;&#10;            // Remove last delivery and try again&#10;            if (!balanced.isEmpty()) {&#10;                log.debug(&quot;Removing delivery from end, trying with {}&quot;, balanced.size() - 1);&#10;                balanced.remove(balanced.size() - 1);&#10;            }&#10;        }&#10;&#10;        // If we get here, even a single delivery exceeds time limit!&#10;        // Move ALL deliveries to next shift or undelivered&#10;        log.error(&quot;Even 0 deliveries exceed time limit! Moving ALL {} deliveries&quot;, clusterDeliveries.size());&#10;&#10;        int nextShift = currentShiftIndex + 1;&#10;        if (allClusters.containsKey(nextShift)) {&#10;            List&lt;Coordinates&gt; nextCluster = allClusters.get(nextShift);&#10;            nextCluster.addAll(0, clusterDeliveries);&#10;            log.info(&quot;Moved all {} deliveries to shift {}&quot;, clusterDeliveries.size(), nextShift);&#10;        } else {&#10;            undelivered.addAll(clusterDeliveries);&#10;            log.info(&quot;Moved all {} deliveries to undelivered&quot;, clusterDeliveries.size());&#10;        }&#10;&#10;        return new ArrayList&lt;&gt;();  // Return empty for this shift&#10;    }&#10;&#10;    /**&#10;     * Convert optimized clusters to Stop objects&#10;     */&#10;    private List&lt;Stop&gt; convertClustersToStops(&#10;            Coordinates depot,&#10;            Coordinates warehouse,&#10;            ClusterResult clusters,&#10;            List&lt;Parcel&gt; parcelList&#10;    ) {&#10;        List&lt;Stop&gt; allStops = new ArrayList&lt;&gt;();&#10;&#10;        // Add depot as first stop&#10;        Stop.addOrUpdateStop(allStops, new Stop(depot, new ArrayList&lt;&gt;(), StopType.DEPOT));&#10;&#10;        // Add warehouse stop&#10;        Stop.addOrUpdateStop(allStops, new Stop(warehouse, new ArrayList&lt;&gt;(), StopType.WAREHOUSE));&#10;&#10;        // Add delivery stops from all clusters&#10;        for (Map.Entry&lt;Integer, List&lt;Coordinates&gt;&gt; entry : clusters.getShiftClusters().entrySet()) {&#10;            List&lt;Coordinates&gt; clusterCoords = entry.getValue();&#10;&#10;            for (Coordinates coord : clusterCoords) {&#10;                // Find parcels for this coordinate&#10;                List&lt;Parcel&gt; parcelsForStop = findParcelsForCoordinate(coord, parcelList);&#10;                Stop deliveryStop = new Stop(coord, parcelsForStop, StopType.CUSTOMER);&#10;                Stop.addOrUpdateStop(allStops, deliveryStop);&#10;            }&#10;        }&#10;&#10;        // Add depot as last stop (return) - use add() not addOrUpdateStop() to avoid merging with start depot&#10;        allStops.add(new Stop(depot, new ArrayList&lt;&gt;(), StopType.DEPOT));&#10;&#10;        return allStops;&#10;    }&#10;&#10;    /**&#10;     * Find all parcels that should be delivered to a specific coordinate&#10;     */&#10;    private List&lt;Parcel&gt; findParcelsForCoordinate(Coordinates coord, List&lt;Parcel&gt; allParcels) {&#10;        List&lt;Parcel&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        if (allParcels == null || coord == null) {&#10;            return result;&#10;        }&#10;&#10;        for (Parcel parcel : allParcels) {&#10;            if (Math.abs(parcel.getDeliveryLatitude() - coord.getLatitude()) &lt; 0.000001 &amp;&amp;&#10;                Math.abs(parcel.getDeliveryLongitude() - coord.getLongitude()) &lt; 0.000001) {&#10;                result.add(parcel);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.saxion.proj.tfms.routing.service.computation.helper.tomtom;&#10;&#10;import com.saxion.proj.tfms.commons.constants.StopType;&#10;import com.saxion.proj.tfms.routing.model.*;&#10;import com.saxion.proj.tfms.routing.service.computation.helper.RoutingProvider;&#10;import com.saxion.proj.tfms.routing.service.computation.helper.constants.Patterns;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@Service(&quot;RoutingProblemSolver&quot;)&#10;public class RoutingProblemSolver implements RoutingProvider {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(RoutingProblemSolver.class);&#10;&#10;    @Autowired&#10;    private TomTomRouteCalculator tomTomRouteCalculator;&#10;&#10;&#10;    @Override&#10;    public List&lt;Stop&gt; calculateRoute(RouteCoordinatesGroup routeCoordinatesGroup) {&#10;&#10;        Coordinates depotCoordinate = routeCoordinatesGroup.getDepot();&#10;        Coordinates warehouseCoordinates = routeCoordinatesGroup.getWarehouse();&#10;        List&lt;Coordinates&gt; parcels = routeCoordinatesGroup.getParcels();&#10;        List&lt;Parcel&gt; parcelList = routeCoordinatesGroup.getParcelList();&#10;&#10;&#10;        // Step 1: Initial heuristic clustering by shift time&#10;        Map&lt;Coordinates, Double&gt; coordinatesDistanceMap = HeuristicsDistanceFinder.findStraightDistanceInkm(warehouseCoordinates, parcels);&#10;&#10;        ClusterResult heuristicClusters = HeuristicsClusterMaker.clusterByShift(&#10;                coordinatesDistanceMap,&#10;                warehouseCoordinates,&#10;                Patterns.PATTERN_HEURISTIC,&#10;                8,&#10;                40&#10;        );&#10;&#10;        // Step 2: Optimize each cluster using TomTom and rebalance if needed&#10;        ClusterResult optimizedClusters = optimizeClustersWithTomTom(&#10;                warehouseCoordinates,&#10;                heuristicClusters,&#10;                Patterns.PATTERN_REALISTIC&#10;        );&#10;&#10;        double a = optimizedClusters.getClusterDistanceinKm();&#10;        int b = optimizedClusters.getClusteringTimeInMinutes();&#10;        // Step 3: Convert optimized clusters to stops&#10;        List&lt;Stop&gt; stops = convertClustersToStops(&#10;                depotCoordinate,&#10;                warehouseCoordinates,&#10;                optimizedClusters,&#10;                parcelList&#10;        );&#10;&#10;        return stops;&#10;    }&#10;&#10;&#10;&#10;    /**&#10;     * Optimize each cluster using TomTom API and rebalance deliveries if time exceeds 2.5 hours&#10;     * Also stores route metrics (distance, time) for each truck/shift&#10;     * IMPORTANT: Deduplicates identical coordinates before sending to TomTom to avoid duplicate waypoints&#10;     */&#10;    private ClusterResult optimizeClustersWithTomTom(&#10;            Coordinates warehouse,&#10;            ClusterResult heuristicClusters,&#10;            List&lt;Patterns.ShiftBlock&gt; shiftBlocks&#10;    ) {&#10;        Map&lt;Integer, List&lt;Coordinates&gt;&gt; clusters = heuristicClusters.getShiftClusters();&#10;        List&lt;Coordinates&gt; undelivered = new ArrayList&lt;&gt;(heuristicClusters.getUndeliveredParcels());&#10;        Map&lt;Integer, TruckRouteMetrics&gt; truckMetricsMap = new java.util.HashMap&lt;&gt;();&#10;&#10;        log.debug(&quot;Starting optimization with {} clusters&quot;, clusters.size());&#10;&#10;        // Process each cluster and validate with TomTom&#10;        for (int shiftIndex = 0; shiftIndex &lt; shiftBlocks.size(); shiftIndex++) {&#10;            log.debug(&quot;Processing Shift {}&quot;, shiftIndex);&#10;&#10;            List&lt;Coordinates&gt; clusterDeliveries = clusters.get(shiftIndex);&#10;&#10;            if (clusterDeliveries == null || clusterDeliveries.isEmpty()) {&#10;                log.debug(&quot;Skipping empty cluster for shift {}&quot;, shiftIndex);&#10;                continue;&#10;            }&#10;&#10;            log.debug(&quot;Original cluster deliveries: {}&quot;, clusterDeliveries.size());&#10;&#10;            Patterns.ShiftBlock shift = shiftBlocks.get(shiftIndex);&#10;            int maxTimeSeconds = calculateMaxTimeSeconds(shift);&#10;&#10;            // Deduplicate identical coordinates (multiple parcels at same location = 1 stop for TomTom)&#10;            List&lt;Coordinates&gt; uniqueCoordinates = deduplicateCoordinates(clusterDeliveries);&#10;            log.debug(&quot;After deduplication: {} unique coordinates&quot;, uniqueCoordinates.size());&#10;&#10;            // Get TomTom optimized route and time using UNIQUE coordinates only&#10;            com.fasterxml.jackson.databind.JsonNode routeResponse =&#10;                    tomTomRouteCalculator.getOptimizedRoute(warehouse, uniqueCoordinates);&#10;&#10;            if (routeResponse != null &amp;&amp; routeResponse.has(&quot;routes&quot;) &amp;&amp; routeResponse.get(&quot;routes&quot;).size() &gt; 0) {&#10;                log.debug(&quot;TomTom response received for shift {}&quot;, shiftIndex);&#10;&#10;                com.fasterxml.jackson.databind.JsonNode summary =&#10;                    routeResponse.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;);&#10;&#10;                int actualTimeSeconds = summary.get(&quot;travelTimeInSeconds&quot;).asInt();&#10;                int actualDistanceMeters = summary.get(&quot;lengthInMeters&quot;).asInt();&#10;&#10;                // Extract the REARRANGED coordinates from TomTom response&#10;                List&lt;Coordinates&gt; optimizedSequence = tomTomRouteCalculator.getOptimizedSequence(routeResponse, uniqueCoordinates);&#10;&#10;                log.debug(&quot;Optimized sequence size: {}&quot;, optimizedSequence != null ? optimizedSequence.size() : 0);&#10;&#10;                // Ensure we never store empty list - optimizedSequence should have coordinates&#10;                if (optimizedSequence == null || optimizedSequence.isEmpty()) {&#10;                    log.warn(&quot;Optimized sequence empty for shift {}, using {} unique coordinates as fallback&quot;,&#10;                        shiftIndex, uniqueCoordinates.size());&#10;                    clusters.put(shiftIndex, uniqueCoordinates);&#10;                } else {&#10;                    log.debug(&quot;Shift {}: Storing {} optimized coordinates&quot;, shiftIndex, optimizedSequence.size());&#10;                    clusters.put(shiftIndex, optimizedSequence);&#10;                }&#10;&#10;                // Store metrics for this truck/shift&#10;                TruckRouteMetrics metrics = new TruckRouteMetrics(&#10;                    shiftIndex,&#10;                    actualDistanceMeters,&#10;                    actualTimeSeconds,&#10;                    optimizedSequence == null || optimizedSequence.isEmpty() ? uniqueCoordinates.size() : optimizedSequence.size()&#10;                );&#10;&#10;                // If time exceeds limit, move excess deliveries to next cluster or undelivered&#10;                if (actualTimeSeconds &gt; maxTimeSeconds) {&#10;                    log.info(&quot;Time exceeded for shift {} ({}s &gt; {}s), rebalancing&quot;,&#10;                        shiftIndex, actualTimeSeconds, maxTimeSeconds);&#10;&#10;                    List&lt;Coordinates&gt; toRebalance = (optimizedSequence == null || optimizedSequence.isEmpty()) ? uniqueCoordinates : optimizedSequence;&#10;&#10;                    List&lt;Coordinates&gt; rebalanced = rebalanceCluster(&#10;                            warehouse,&#10;                            toRebalance,&#10;                            maxTimeSeconds,&#10;                            shiftIndex,&#10;                            clusters,&#10;                            undelivered&#10;                    );&#10;&#10;                    log.debug(&quot;After rebalancing: {} coordinates&quot;, rebalanced.size());&#10;&#10;                    // Deduplicate rebalanced list before storing&#10;                    List&lt;Coordinates&gt; deduplicatedRebalanced = deduplicateCoordinates(rebalanced);&#10;                    log.debug(&quot;After deduplication: {} coordinates&quot;, deduplicatedRebalanced.size());&#10;&#10;                    clusters.put(shiftIndex, deduplicatedRebalanced);&#10;&#10;                    // Update metrics after rebalancing&#10;                    com.fasterxml.jackson.databind.JsonNode rebalancedResponse =&#10;                            tomTomRouteCalculator.getOptimizedRoute(warehouse, deduplicatedRebalanced);&#10;                    if (rebalancedResponse != null &amp;&amp; rebalancedResponse.has(&quot;routes&quot;) &amp;&amp; rebalancedResponse.get(&quot;routes&quot;).size() &gt; 0) {&#10;                        TruckRouteMetrics updatedMetrics = getTruckRouteMetrics(rebalancedResponse, shiftIndex, deduplicatedRebalanced);&#10;&#10;                        log.debug(&quot;Updated metrics after rebalancing for shift {}&quot;, shiftIndex);&#10;                    }&#10;                }&#10;            } else {&#10;                // FALLBACK: TomTom API failed or returned empty response&#10;                // Keep the original deduplicated coordinates instead of losing them&#10;                log.warn(&quot;TomTom API failed for shift {}, using {} fallback coordinates&quot;,&#10;                    shiftIndex, uniqueCoordinates.size());&#10;                clusters.put(shiftIndex, uniqueCoordinates);&#10;&#10;                // Try to estimate metrics manually&#10;                int estimatedTime = (uniqueCoordinates.size() - 1) * 600; // ~10 min per stop estimate&#10;                TruckRouteMetrics metrics = new TruckRouteMetrics(&#10;                    shiftIndex,&#10;                    0,  // Distance unknown&#10;                    estimatedTime,&#10;                    uniqueCoordinates.size()&#10;                );&#10;&#10;            }&#10;&#10;            // Verify what's actually in the cluster now&#10;            List&lt;Coordinates&gt; verifyCluster = clusters.get(shiftIndex);&#10;            log.debug(&quot;Cluster {} now has {} coordinates&quot;, shiftIndex,&#10;                verifyCluster != null ? verifyCluster.size() : 0);&#10;        }&#10;&#10;        log.debug(&quot;Final cluster status: {} clusters processed&quot;, shiftBlocks.size());&#10;&#10;        // Update time and distance in ClusterResult&#10;        ClusterResult result = new ClusterResult(clusters, undelivered);&#10;&#10;        // Calculate total distance and time from all truck metrics&#10;        int totalDistanceMeters = 0;&#10;        int totalTimeSeconds = 0;&#10;&#10;&#10;        // Convert to appropriate units and set in ClusterResult&#10;        result.setClusterDistanceinKm(totalDistanceMeters / 1000.0);&#10;        result.setClusteringTimeInMinutes(totalTimeSeconds / 60);&#10;&#10;        log.info(&quot;Total route metrics - Distance: {} km, Time: {} minutes&quot;,&#10;            result.getClusterDistanceinKm(), result.getClusteringTimeInMinutes());&#10;&#10;        return result;&#10;    }&#10;&#10;    private TruckRouteMetrics getTruckRouteMetrics(com.fasterxml.jackson.databind.JsonNode rebalancedResponse, int shiftIndex, List&lt;Coordinates&gt; rebalanced) {&#10;        com.fasterxml.jackson.databind.JsonNode rebalancedSummary =&#10;            rebalancedResponse.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;);&#10;&#10;        TruckRouteMetrics updatedMetrics = new TruckRouteMetrics(&#10;                shiftIndex,&#10;            rebalancedSummary.get(&quot;lengthInMeters&quot;).asInt(),&#10;            rebalancedSummary.get(&quot;travelTimeInSeconds&quot;).asInt(),&#10;            rebalanced.size()&#10;        );&#10;        return updatedMetrics;&#10;    }&#10;&#10;    /**&#10;     * Calculate maximum time in seconds for a shift (work time - breaks + buffer)&#10;     */&#10;    private int calculateMaxTimeSeconds(Patterns.ShiftBlock shift) {&#10;        int trafficBuffer = (shift.workMinutes / 60) * shift.trafficBufferPerHour;&#10;        int availableMinutes = shift.workMinutes - shift.breakMinutes + trafficBuffer;&#10;        return availableMinutes * 60; // Convert to seconds&#10;    }&#10;&#10;    /**&#10;     * Remove duplicate coordinates (multiple parcels at same location)&#10;     * Keeps first occurrence, removes subsequent identical coordinates&#10;     * @param coordinates List that may contain duplicates&#10;     * @return List with only unique coordinates (by lat/lon)&#10;     */&#10;    private List&lt;Coordinates&gt; deduplicateCoordinates(List&lt;Coordinates&gt; coordinates) {&#10;        List&lt;Coordinates&gt; unique = new ArrayList&lt;&gt;();&#10;&#10;        for (Coordinates coord : coordinates) {&#10;            boolean isDuplicate = false;&#10;&#10;            // Check if this coordinate already exists in unique list&#10;            for (Coordinates existing : unique) {&#10;                if (Math.abs(existing.getLatitude() - coord.getLatitude()) &lt; 0.000001 &amp;&amp;&#10;                    Math.abs(existing.getLongitude() - coord.getLongitude()) &lt; 0.000001) {&#10;                    isDuplicate = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            // Add only if not a duplicate&#10;            if (!isDuplicate) {&#10;                unique.add(coord);&#10;            }&#10;        }&#10;&#10;        return unique;&#10;    }&#10;&#10;    /**&#10;     * Rebalance cluster by removing deliveries until time constraint is met&#10;     * If even a single delivery exceeds time, move all to next shift/undelivered&#10;     */&#10;    private List&lt;Coordinates&gt; rebalanceCluster(&#10;            Coordinates warehouse,&#10;            List&lt;Coordinates&gt; clusterDeliveries,&#10;            int maxTimeSeconds,&#10;            int currentShiftIndex,&#10;            Map&lt;Integer, List&lt;Coordinates&gt;&gt; allClusters,&#10;            List&lt;Coordinates&gt; undelivered&#10;    ) {&#10;        List&lt;Coordinates&gt; balanced = new ArrayList&lt;&gt;(clusterDeliveries);&#10;&#10;        log.debug(&quot;Rebalancing: Starting with {} deliveries, max time: {}s&quot;, balanced.size(), maxTimeSeconds);&#10;&#10;        // Remove deliveries from the end until time fits&#10;        while (!balanced.isEmpty()) {&#10;            com.fasterxml.jackson.databind.JsonNode response =&#10;                    tomTomRouteCalculator.getOptimizedRoute(warehouse, balanced);&#10;&#10;            if (response != null &amp;&amp; response.has(&quot;routes&quot;) &amp;&amp; response.get(&quot;routes&quot;).size() &gt; 0) {&#10;                int time = response.get(&quot;routes&quot;).get(0).get(&quot;summary&quot;).get(&quot;travelTimeInSeconds&quot;).asInt();&#10;&#10;                log.debug(&quot;Testing with {} deliveries: {}s&quot;, balanced.size(), time);&#10;&#10;                if (time &lt;= maxTimeSeconds) {&#10;                    // Time fits! Now move excess deliveries to next cluster or undelivered&#10;                    // Important: collect removed items before modifying balanced list&#10;                    List&lt;Coordinates&gt; removed = new ArrayList&lt;&gt;();&#10;                    for (int i = balanced.size(); i &lt; clusterDeliveries.size(); i++) {&#10;                        removed.add(clusterDeliveries.get(i));&#10;                    }&#10;&#10;                    if (!removed.isEmpty()) {&#10;                        log.info(&quot;Moving {} deliveries to next shift/undelivered&quot;, removed.size());&#10;&#10;                        // Try to add to next cluster&#10;                        int nextShift = currentShiftIndex + 1;&#10;                        if (allClusters.containsKey(nextShift)) {&#10;                            List&lt;Coordinates&gt; nextCluster = allClusters.get(nextShift);&#10;                            nextCluster.addAll(0, removed); // Add at beginning&#10;                            log.debug(&quot;Added {} deliveries to shift {}&quot;, removed.size(), nextShift);&#10;                        } else {&#10;                            undelivered.addAll(removed);&#10;                            log.debug(&quot;Added {} deliveries to undelivered list&quot;, removed.size());&#10;                        }&#10;                    }&#10;&#10;                    log.debug(&quot;Rebalancing complete: keeping {} deliveries&quot;, balanced.size());&#10;                    return balanced;&#10;                }&#10;            }&#10;&#10;            // Remove last delivery and try again&#10;            if (!balanced.isEmpty()) {&#10;                log.debug(&quot;Removing delivery from end, trying with {}&quot;, balanced.size() - 1);&#10;                balanced.remove(balanced.size() - 1);&#10;            }&#10;        }&#10;&#10;        // If we get here, even a single delivery exceeds time limit!&#10;        // Move ALL deliveries to next shift or undelivered&#10;        log.error(&quot;Even 0 deliveries exceed time limit! Moving ALL {} deliveries&quot;, clusterDeliveries.size());&#10;&#10;        int nextShift = currentShiftIndex + 1;&#10;        if (allClusters.containsKey(nextShift)) {&#10;            List&lt;Coordinates&gt; nextCluster = allClusters.get(nextShift);&#10;            nextCluster.addAll(0, clusterDeliveries);&#10;            log.info(&quot;Moved all {} deliveries to shift {}&quot;, clusterDeliveries.size(), nextShift);&#10;        } else {&#10;            undelivered.addAll(clusterDeliveries);&#10;            log.info(&quot;Moved all {} deliveries to undelivered&quot;, clusterDeliveries.size());&#10;        }&#10;&#10;        return new ArrayList&lt;&gt;();  // Return empty for this shift&#10;    }&#10;&#10;    /**&#10;     * Convert optimized clusters to Stop objects&#10;     */&#10;    private List&lt;Stop&gt; convertClustersToStops(&#10;            Coordinates depot,&#10;            Coordinates warehouse,&#10;            ClusterResult clusters,&#10;            List&lt;Parcel&gt; parcelList&#10;    ) {&#10;        List&lt;Stop&gt; allStops = new ArrayList&lt;&gt;();&#10;&#10;        // Add depot as first stop&#10;        Stop.addOrUpdateStop(allStops, new Stop(depot, new ArrayList&lt;&gt;(), StopType.DEPOT));&#10;&#10;        // Add warehouse stop&#10;        Stop.addOrUpdateStop(allStops, new Stop(warehouse, new ArrayList&lt;&gt;(), StopType.WAREHOUSE));&#10;&#10;        // Add delivery stops from all clusters&#10;        for (Map.Entry&lt;Integer, List&lt;Coordinates&gt;&gt; entry : clusters.getShiftClusters().entrySet()) {&#10;            List&lt;Coordinates&gt; clusterCoords = entry.getValue();&#10;&#10;            for (Coordinates coord : clusterCoords) {&#10;                // Find parcels for this coordinate&#10;                List&lt;Parcel&gt; parcelsForStop = findParcelsForCoordinate(coord, parcelList);&#10;                Stop deliveryStop = new Stop(coord, parcelsForStop, StopType.CUSTOMER);&#10;                Stop.addOrUpdateStop(allStops, deliveryStop);&#10;            }&#10;        }&#10;&#10;        // Add depot as last stop (return) - use add() not addOrUpdateStop() to avoid merging with start depot&#10;        allStops.add(new Stop(depot, new ArrayList&lt;&gt;(), StopType.DEPOT));&#10;&#10;        return allStops;&#10;    }&#10;&#10;    /**&#10;     * Find all parcels that should be delivered to a specific coordinate&#10;     */&#10;    private List&lt;Parcel&gt; findParcelsForCoordinate(Coordinates coord, List&lt;Parcel&gt; allParcels) {&#10;        List&lt;Parcel&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        if (allParcels == null || coord == null) {&#10;            return result;&#10;        }&#10;&#10;        for (Parcel parcel : allParcels) {&#10;            if (Math.abs(parcel.getDeliveryLatitude() - coord.getLatitude()) &lt; 0.000001 &amp;&amp;&#10;                Math.abs(parcel.getDeliveryLongitude() - coord.getLongitude()) &lt; 0.000001) {&#10;                result.add(parcel);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/interfaces/LocationMappingService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/interfaces/LocationMappingService.java" />
              <option name="updatedContent" value="package com.saxion.proj.tfms.routing.service.interfaces;&#10;&#10;import com.saxion.proj.tfms.routing.dto.VrpRequestDto;&#10;import com.saxion.proj.tfms.routing.service.DistanceMatrixService;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Interface for location mapping and management&#10; * Follows Single Responsibility Principle - focused on location handling&#10; */&#10;public interface LocationMappingService {&#10;    &#10;    /**&#10;     * Build location mapping from VRP request&#10;     * &#10;     * @param request VRP request containing location data&#10;     * @return LocationMapping with indexed locations&#10;     */&#10;    LocationMapping buildLocationMapping(VrpRequestDto request);&#10;    &#10;    /**&#10;     * Location mapping data structure&#10;     */&#10;    class LocationMapping {&#10;        private final List&lt;DistanceMatrixService.Location&gt; locations;&#10;        private final Map&lt;String, Integer&gt; locationIndices;&#10;        private final int depotIndex;&#10;        &#10;        public LocationMapping(List&lt;DistanceMatrixService.Location&gt; locations,&#10;                             Map&lt;String, Integer&gt; locationIndices,&#10;                             int depotIndex) {&#10;            this.locations = locations;&#10;            this.locationIndices = locationIndices;&#10;            this.depotIndex = depotIndex;&#10;        }&#10;        &#10;        public List&lt;DistanceMatrixService.Location&gt; getLocations() { return locations; }&#10;        public Map&lt;String, Integer&gt; getLocationIndices() { return locationIndices; }&#10;        public int getDepotIndex() { return depotIndex; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/interfaces/VrpRequestValidator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tfms-modules/routing-distribution-module/routing-service/src/main/java/com/saxion/proj/tfms/routing/service/interfaces/VrpRequestValidator.java" />
              <option name="updatedContent" value="package com.saxion.proj.tfms.routing.service.interfaces;&#10;&#10;import com.saxion.proj.tfms.routing.dto.VrpRequestDto;&#10;&#10;/**&#10; * Interface for VRP request validation&#10; * Follows Single Responsibility Principle - focused only on validation&#10; */&#10;public interface VrpRequestValidator {&#10;    &#10;    /**&#10;     * Validate VRP request for common issues and constraints&#10;     * &#10;     * @param request VRP request to validate&#10;     * @throws IllegalArgumentException if validation fails&#10;     */&#10;    void validateRequest(VrpRequestDto request);&#10;    &#10;    /**&#10;     * Check if request is valid without throwing exceptions&#10;     * &#10;     * @param request VRP request to check&#10;     * @return ValidationResult containing status and error messages&#10;     */&#10;    ValidationResult isValid(VrpRequestDto request);&#10;    &#10;    /**&#10;     * Validation result container&#10;     */&#10;    class ValidationResult {&#10;        private final boolean valid;&#10;        private final String errorMessage;&#10;        &#10;        public ValidationResult(boolean valid, String errorMessage) {&#10;            this.valid = valid;&#10;            this.errorMessage = errorMessage;&#10;        }&#10;        &#10;        public boolean isValid() { return valid; }&#10;        public String getErrorMessage() { return errorMessage; }&#10;        &#10;        public static ValidationResult success() {&#10;            return new ValidationResult(true, null);&#10;        }&#10;        &#10;        public static ValidationResult failure(String message) {&#10;            return new ValidationResult(false, message);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>